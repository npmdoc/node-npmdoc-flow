<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

    >flow (v0.2.3)</a>
</h1>
<h4>Flow-JS makes it easy to express multi-step asynchronous logic in Node or the browser</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow">module flow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.anyError">
            function <span class="apidocSignatureSpan">flow.</span>anyError
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.define">
            function <span class="apidocSignatureSpan">flow.</span>define
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.exec">
            function <span class="apidocSignatureSpan">flow.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach">
            function <span class="apidocSignatureSpan">flow.</span>serialForEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.exec">
            function <span class="apidocSignatureSpan">flow.</span>serialForEach.exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">flow.</span>serialForEach.blocks</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.anyError">module flow.anyError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.anyError.anyError">
            function <span class="apidocSignatureSpan">flow.</span>anyError
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.define">module flow.define</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.define.define">
            function <span class="apidocSignatureSpan">flow.</span>define
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.exec">module flow.exec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.exec.exec">
            function <span class="apidocSignatureSpan">flow.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.serialForEach">module flow.serialForEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.serialForEach">
            function <span class="apidocSignatureSpan">flow.</span>serialForEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.exec">
            function <span class="apidocSignatureSpan">flow.serialForEach.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">flow.serialForEach.</span>blocks</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.serialForEach.blocks">module flow.serialForEach.blocks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.blocks.0">
            function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>0
            <span class="apidocSignatureSpan">(items, job, between, finish)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.blocks.1">
            function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.blocks.2">
            function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.flow.serialForEach.exec">module flow.serialForEach.exec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.flow.serialForEach.exec.exec">
            function <span class="apidocSignatureSpan">flow.serialForEach.</span>exec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow" id="apidoc.module.flow">module flow</a></h1>


    <h2>
        <a href="#apidoc.element.flow.anyError" id="apidoc.element.flow.anyError">
        function <span class="apidocSignatureSpan">flow.</span>anyError
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function anyError(results) {
		var r, _i, _len;
		for (_i = 0, _len = results.length; _i &#x3c; _len; _i++) {
			r = results[_i];
			if (r[0]) {
				return r[0];
			}
		}
		return null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.define" id="apidoc.element.flow.define">
        function <span class="apidocSignatureSpan">flow.</span>define
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define() {	
		var thisFlow = function() {
			applyArgs(thisFlow.exec, thisFlow, arguments);
		}
		
		thisFlow.blocks = arguments;
		
		thisFlow.exec = function() {
			// The flowState is the actual object each step in the flow is applied to. It acts as a
			// callback to the next function. It also maintains the internal state of each execution
			// and acts as a place for users to save values between steps of the flow.
			var flowState = function() {
				if (flowState.__frozen) return;
				
				if (flowState.__timeoutId) {
					clearTimeout(flowState.__timeoutId);
					delete flowState.__timeoutId;
				}
				
				var blockIdx = flowState.__nextBlockIdx ++;
				var block = thisFlow.blocks[blockIdx];
				
				if (block === undefined) {
					return;
				}
				else {
					applyArgs(block, flowState, arguments);
				}
			}
			
			// __nextBlockIdx specifies which function is the next step in the flow.
			flowState.__nextBlockIdx = 0;
			
			// __multiCount is incremented every time MULTI is used to createa a multiplexed callback
			flowState.__multiCount = 0;
			
			// __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
			flowState.__multiOutputs = [];
			
			// REWIND signals that the next call to thisFlow should repeat this step. It allows you
			// to create serial loops.
			flowState.REWIND = function() {
				flowState.__nextBlockIdx -= 1;
			}
			
			// MULTI can be used to generate callbacks that must ALL be called before the next step
			// in the flow is executed. Arguments to those callbacks are accumulated, and an array of
			// of those arguments objects is sent as the one argument to the next step in the flow.
			// @param {String} resultId An identifier to get the result of a multi call.
			flowState.MULTI = function(resultId) {
				flowState.__multiCount += 1;
				return function() {
					flowState.__multiCount -= 1;
					flowState.__multiOutputs.push(arguments);

          if (resultId) {
            var result = arguments.length &#x3c;= 1 ? arguments[0] : arguments
            flowState.__multiOutputs[resultId] = result;
          }
					
					if (flowState.__multiCount === 0) {
						var multiOutputs = flowState.__multiOutputs;
						flowState.__multiOutputs = [];
						flowState(multiOutputs);
					}
				}
			}
						
			// TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
			// timeout is cleared if the next flow step happens first.
			flowState.TIMEOUT = function(milliseconds, timeoutCallback) {
				if (flowState.__timeoutId !== undefined) {
					throw new Error(&#x22;timeout already set for this flow step&#x22;);
				}
				
				flowState.__timeoutId = setTimeout(function() {
					flowState.__frozen = true;
					timeoutCallback();
				}, milliseconds);
			}
			
			applyArgs(flowState, this, arguments);
		}
		
		return thisFlow;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Each function in the flow is called with a special `this` object which maintains the
state of the flow&#x27;s execution, acts as a container for saving values for use between
functions in the flow, and acts as a callback to the next function in the flow.

Here is an example to make this clear:

	// define a flow for renaming a file and then printing its stats
	var renameAndStat = flow.<span class="apidocCodeKeywordSpan">define</span>(
	
		function(fromName, toName) {
			// arguments passed to renameAndStat() will pass through to this first function
			
			this.toName = toName; // save to be used in the next function
			fs.rename(fromName, toName, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.exec" id="apidoc.element.flow.exec">
        function <span class="apidocSignatureSpan">flow.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exec() {
		var flow = typeof exports != &#x27;undefined&#x27; ? exports : window.flow;
		applyArgs(flow.define, flow, arguments)();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, complete);
	});

Now look at the same example using Flow-JS:

	flow.<span class="apidocCodeKeywordSpan">exec</span>(
		function() {
			dbGet(&#x27;userIdOf:bobvance&#x27;, this);
			
		},function(userId) {
			dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, this.MULTI());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.serialForEach" id="apidoc.element.flow.serialForEach">
        function <span class="apidocSignatureSpan">flow.</span>serialForEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialForEach = function () {
			applyArgs(thisFlow.exec, thisFlow, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

serialForEach
---------------

Flow-JS comes with a convience function called `flow.serialForEach` which can be used to
apply an asynchronous function to each element in an array of values serially:

	flow.<span class="apidocCodeKeywordSpan">serialForEach</span>([1, 2, 3, 4], function(val) {
		keystore.increment(&#x22;counter&#x22;, val, this);
	},function(error, newVal) {
		if (error) throw error;
		sys.puts(&#x27;newVal: &#x27; + newVal);
	},function() {
		sys.puts(&#x27;This is the end!&#x27;);
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.serialForEach.exec" id="apidoc.element.flow.serialForEach.exec">
        function <span class="apidocSignatureSpan">flow.</span>serialForEach.exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialForEach.exec = function () {
			// The flowState is the actual object each step in the flow is applied to. It acts as a
			// callback to the next function. It also maintains the internal state of each execution
			// and acts as a place for users to save values between steps of the flow.
			var flowState = function() {
				if (flowState.__frozen) return;
				
				if (flowState.__timeoutId) {
					clearTimeout(flowState.__timeoutId);
					delete flowState.__timeoutId;
				}
				
				var blockIdx = flowState.__nextBlockIdx ++;
				var block = thisFlow.blocks[blockIdx];
				
				if (block === undefined) {
					return;
				}
				else {
					applyArgs(block, flowState, arguments);
				}
			}
			
			// __nextBlockIdx specifies which function is the next step in the flow.
			flowState.__nextBlockIdx = 0;
			
			// __multiCount is incremented every time MULTI is used to createa a multiplexed callback
			flowState.__multiCount = 0;
			
			// __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
			flowState.__multiOutputs = [];
			
			// REWIND signals that the next call to thisFlow should repeat this step. It allows you
			// to create serial loops.
			flowState.REWIND = function() {
				flowState.__nextBlockIdx -= 1;
			}
			
			// MULTI can be used to generate callbacks that must ALL be called before the next step
			// in the flow is executed. Arguments to those callbacks are accumulated, and an array of
			// of those arguments objects is sent as the one argument to the next step in the flow.
			// @param {String} resultId An identifier to get the result of a multi call.
			flowState.MULTI = function(resultId) {
				flowState.__multiCount += 1;
				return function() {
					flowState.__multiCount -= 1;
					flowState.__multiOutputs.push(arguments);

          if (resultId) {
            var result = arguments.length &#x3c;= 1 ? arguments[0] : arguments
            flowState.__multiOutputs[resultId] = result;
          }
					
					if (flowState.__multiCount === 0) {
						var multiOutputs = flowState.__multiOutputs;
						flowState.__multiOutputs = [];
						flowState(multiOutputs);
					}
				}
			}
						
			// TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
			// timeout is cleared if the next flow step happens first.
			flowState.TIMEOUT = function(milliseconds, timeoutCallback) {
				if (flowState.__timeoutId !== undefined) {
					throw new Error(&#x22;timeout already set for this flow step&#x22;);
				}
				
				flowState.__timeoutId = setTimeout(function() {
					flowState.__frozen = true;
					timeoutCallback();
				}, milliseconds);
			}
			
			applyArgs(flowState, this, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.anyError" id="apidoc.module.flow.anyError">module flow.anyError</a></h1>


    <h2>
        <a href="#apidoc.element.flow.anyError.anyError" id="apidoc.element.flow.anyError.anyError">
        function <span class="apidocSignatureSpan">flow.</span>anyError
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function anyError(results) {
		var r, _i, _len;
		for (_i = 0, _len = results.length; _i &#x3c; _len; _i++) {
			r = results[_i];
			if (r[0]) {
				return r[0];
			}
		}
		return null;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.define" id="apidoc.module.flow.define">module flow.define</a></h1>


    <h2>
        <a href="#apidoc.element.flow.define.define" id="apidoc.element.flow.define.define">
        function <span class="apidocSignatureSpan">flow.</span>define
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define() {	
		var thisFlow = function() {
			applyArgs(thisFlow.exec, thisFlow, arguments);
		}
		
		thisFlow.blocks = arguments;
		
		thisFlow.exec = function() {
			// The flowState is the actual object each step in the flow is applied to. It acts as a
			// callback to the next function. It also maintains the internal state of each execution
			// and acts as a place for users to save values between steps of the flow.
			var flowState = function() {
				if (flowState.__frozen) return;
				
				if (flowState.__timeoutId) {
					clearTimeout(flowState.__timeoutId);
					delete flowState.__timeoutId;
				}
				
				var blockIdx = flowState.__nextBlockIdx ++;
				var block = thisFlow.blocks[blockIdx];
				
				if (block === undefined) {
					return;
				}
				else {
					applyArgs(block, flowState, arguments);
				}
			}
			
			// __nextBlockIdx specifies which function is the next step in the flow.
			flowState.__nextBlockIdx = 0;
			
			// __multiCount is incremented every time MULTI is used to createa a multiplexed callback
			flowState.__multiCount = 0;
			
			// __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
			flowState.__multiOutputs = [];
			
			// REWIND signals that the next call to thisFlow should repeat this step. It allows you
			// to create serial loops.
			flowState.REWIND = function() {
				flowState.__nextBlockIdx -= 1;
			}
			
			// MULTI can be used to generate callbacks that must ALL be called before the next step
			// in the flow is executed. Arguments to those callbacks are accumulated, and an array of
			// of those arguments objects is sent as the one argument to the next step in the flow.
			// @param {String} resultId An identifier to get the result of a multi call.
			flowState.MULTI = function(resultId) {
				flowState.__multiCount += 1;
				return function() {
					flowState.__multiCount -= 1;
					flowState.__multiOutputs.push(arguments);

          if (resultId) {
            var result = arguments.length &#x3c;= 1 ? arguments[0] : arguments
            flowState.__multiOutputs[resultId] = result;
          }
					
					if (flowState.__multiCount === 0) {
						var multiOutputs = flowState.__multiOutputs;
						flowState.__multiOutputs = [];
						flowState(multiOutputs);
					}
				}
			}
						
			// TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
			// timeout is cleared if the next flow step happens first.
			flowState.TIMEOUT = function(milliseconds, timeoutCallback) {
				if (flowState.__timeoutId !== undefined) {
					throw new Error(&#x22;timeout already set for this flow step&#x22;);
				}
				
				flowState.__timeoutId = setTimeout(function() {
					flowState.__frozen = true;
					timeoutCallback();
				}, milliseconds);
			}
			
			applyArgs(flowState, this, arguments);
		}
		
		return thisFlow;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Each function in the flow is called with a special `this` object which maintains the
state of the flow&#x27;s execution, acts as a container for saving values for use between
functions in the flow, and acts as a callback to the next function in the flow.

Here is an example to make this clear:

	// define a flow for renaming a file and then printing its stats
	var renameAndStat = flow.<span class="apidocCodeKeywordSpan">define</span>(
	
		function(fromName, toName) {
			// arguments passed to renameAndStat() will pass through to this first function
			
			this.toName = toName; // save to be used in the next function
			fs.rename(fromName, toName, this);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.exec" id="apidoc.module.flow.exec">module flow.exec</a></h1>


    <h2>
        <a href="#apidoc.element.flow.exec.exec" id="apidoc.element.flow.exec.exec">
        function <span class="apidocSignatureSpan">flow.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exec() {
		var flow = typeof exports != &#x27;undefined&#x27; ? exports : window.flow;
		applyArgs(flow.define, flow, arguments)();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, complete);
	});

Now look at the same example using Flow-JS:

	flow.<span class="apidocCodeKeywordSpan">exec</span>(
		function() {
			dbGet(&#x27;userIdOf:bobvance&#x27;, this);
			
		},function(userId) {
			dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, this.MULTI());
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.serialForEach" id="apidoc.module.flow.serialForEach">module flow.serialForEach</a></h1>


    <h2>
        <a href="#apidoc.element.flow.serialForEach.serialForEach" id="apidoc.element.flow.serialForEach.serialForEach">
        function <span class="apidocSignatureSpan">flow.</span>serialForEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialForEach = function () {
			applyArgs(thisFlow.exec, thisFlow, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

serialForEach
---------------

Flow-JS comes with a convience function called `flow.serialForEach` which can be used to
apply an asynchronous function to each element in an array of values serially:

	flow.<span class="apidocCodeKeywordSpan">serialForEach</span>([1, 2, 3, 4], function(val) {
		keystore.increment(&#x22;counter&#x22;, val, this);
	},function(error, newVal) {
		if (error) throw error;
		sys.puts(&#x27;newVal: &#x27; + newVal);
	},function() {
		sys.puts(&#x27;This is the end!&#x27;);
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.serialForEach.exec" id="apidoc.element.flow.serialForEach.exec">
        function <span class="apidocSignatureSpan">flow.serialForEach.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
			// The flowState is the actual object each step in the flow is applied to. It acts as a
			// callback to the next function. It also maintains the internal state of each execution
			// and acts as a place for users to save values between steps of the flow.
			var flowState = function() {
				if (flowState.__frozen) return;
				
				if (flowState.__timeoutId) {
					clearTimeout(flowState.__timeoutId);
					delete flowState.__timeoutId;
				}
				
				var blockIdx = flowState.__nextBlockIdx ++;
				var block = thisFlow.blocks[blockIdx];
				
				if (block === undefined) {
					return;
				}
				else {
					applyArgs(block, flowState, arguments);
				}
			}
			
			// __nextBlockIdx specifies which function is the next step in the flow.
			flowState.__nextBlockIdx = 0;
			
			// __multiCount is incremented every time MULTI is used to createa a multiplexed callback
			flowState.__multiCount = 0;
			
			// __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
			flowState.__multiOutputs = [];
			
			// REWIND signals that the next call to thisFlow should repeat this step. It allows you
			// to create serial loops.
			flowState.REWIND = function() {
				flowState.__nextBlockIdx -= 1;
			}
			
			// MULTI can be used to generate callbacks that must ALL be called before the next step
			// in the flow is executed. Arguments to those callbacks are accumulated, and an array of
			// of those arguments objects is sent as the one argument to the next step in the flow.
			// @param {String} resultId An identifier to get the result of a multi call.
			flowState.MULTI = function(resultId) {
				flowState.__multiCount += 1;
				return function() {
					flowState.__multiCount -= 1;
					flowState.__multiOutputs.push(arguments);

          if (resultId) {
            var result = arguments.length &#x3c;= 1 ? arguments[0] : arguments
            flowState.__multiOutputs[resultId] = result;
          }
					
					if (flowState.__multiCount === 0) {
						var multiOutputs = flowState.__multiOutputs;
						flowState.__multiOutputs = [];
						flowState(multiOutputs);
					}
				}
			}
						
			// TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
			// timeout is cleared if the next flow step happens first.
			flowState.TIMEOUT = function(milliseconds, timeoutCallback) {
				if (flowState.__timeoutId !== undefined) {
					throw new Error(&#x22;timeout already set for this flow step&#x22;);
				}
				
				flowState.__timeoutId = setTimeout(function() {
					flowState.__frozen = true;
					timeoutCallback();
				}, milliseconds);
			}
			
			applyArgs(flowState, this, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, complete);
	});

Now look at the same example using Flow-JS:

	flow.<span class="apidocCodeKeywordSpan">exec</span>(
		function() {
			dbGet(&#x27;userIdOf:bobvance&#x27;, this);
			
		},function(userId) {
			dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, this.MULTI());
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.serialForEach.blocks" id="apidoc.module.flow.serialForEach.blocks">module flow.serialForEach.blocks</a></h1>


    <h2>
        <a href="#apidoc.element.flow.serialForEach.blocks.0" id="apidoc.element.flow.serialForEach.blocks.0">
        function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>0
        <span class="apidocSignatureSpan">(items, job, between, finish)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">0 = function (items, job, between, finish) {
			this.items = items;
			this.curItem = 0;
			this.job = job;
			this.between = between;
			this.finish = finish;
			this();
	
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.serialForEach.blocks.1" id="apidoc.element.flow.serialForEach.blocks.1">
        function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">1 = function () {
			if (this.curItem &#x3e; 0 &#x26;&#x26; this.between) {
				applyArgs(this.between, this, arguments);
			}
			
			if (this.curItem &#x3e;= this.items.length) {
				this();
			}
			else {
				this.REWIND();
				this.curItem += 1;
				this.job(this.items[this.curItem - 1]);
			}
	
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.flow.serialForEach.blocks.2" id="apidoc.element.flow.serialForEach.blocks.2">
        function <span class="apidocSignatureSpan">flow.serialForEach.blocks.</span>2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">2 = function () {
			if (this.finish) this.finish();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.flow.serialForEach.exec" id="apidoc.module.flow.serialForEach.exec">module flow.serialForEach.exec</a></h1>


    <h2>
        <a href="#apidoc.element.flow.serialForEach.exec.exec" id="apidoc.element.flow.serialForEach.exec.exec">
        function <span class="apidocSignatureSpan">flow.serialForEach.</span>exec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function () {
			// The flowState is the actual object each step in the flow is applied to. It acts as a
			// callback to the next function. It also maintains the internal state of each execution
			// and acts as a place for users to save values between steps of the flow.
			var flowState = function() {
				if (flowState.__frozen) return;
				
				if (flowState.__timeoutId) {
					clearTimeout(flowState.__timeoutId);
					delete flowState.__timeoutId;
				}
				
				var blockIdx = flowState.__nextBlockIdx ++;
				var block = thisFlow.blocks[blockIdx];
				
				if (block === undefined) {
					return;
				}
				else {
					applyArgs(block, flowState, arguments);
				}
			}
			
			// __nextBlockIdx specifies which function is the next step in the flow.
			flowState.__nextBlockIdx = 0;
			
			// __multiCount is incremented every time MULTI is used to createa a multiplexed callback
			flowState.__multiCount = 0;
			
			// __multiOutputs accumulates the arguments of each call to callbacks generated by MULTI
			flowState.__multiOutputs = [];
			
			// REWIND signals that the next call to thisFlow should repeat this step. It allows you
			// to create serial loops.
			flowState.REWIND = function() {
				flowState.__nextBlockIdx -= 1;
			}
			
			// MULTI can be used to generate callbacks that must ALL be called before the next step
			// in the flow is executed. Arguments to those callbacks are accumulated, and an array of
			// of those arguments objects is sent as the one argument to the next step in the flow.
			// @param {String} resultId An identifier to get the result of a multi call.
			flowState.MULTI = function(resultId) {
				flowState.__multiCount += 1;
				return function() {
					flowState.__multiCount -= 1;
					flowState.__multiOutputs.push(arguments);

          if (resultId) {
            var result = arguments.length &#x3c;= 1 ? arguments[0] : arguments
            flowState.__multiOutputs[resultId] = result;
          }
					
					if (flowState.__multiCount === 0) {
						var multiOutputs = flowState.__multiOutputs;
						flowState.__multiOutputs = [];
						flowState(multiOutputs);
					}
				}
			}
						
			// TIMEOUT sets a timeout that freezes a flow and calls the provided callback. This
			// timeout is cleared if the next flow step happens first.
			flowState.TIMEOUT = function(milliseconds, timeoutCallback) {
				if (flowState.__timeoutId !== undefined) {
					throw new Error(&#x22;timeout already set for this flow step&#x22;);
				}
				
				flowState.__timeoutId = setTimeout(function() {
					flowState.__frozen = true;
					timeoutCallback();
				}, milliseconds);
			}
			
			applyArgs(flowState, this, arguments);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, complete);
		dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, complete);
	});

Now look at the same example using Flow-JS:

	flow.<span class="apidocCodeKeywordSpan">exec</span>(
		function() {
			dbGet(&#x27;userIdOf:bobvance&#x27;, this);
			
		},function(userId) {
			dbSet(&#x27;user:&#x27; + userId + &#x27;:email&#x27;, &#x27;bobvance@potato.egg&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:firstName&#x27;, &#x27;Bob&#x27;, this.MULTI());
			dbSet(&#x27;user:&#x27; + userId + &#x27;:lastName&#x27;, &#x27;Vance&#x27;, this.MULTI());
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
